#!/usr/bin/env python
# encoding: UTF-8

import warnings
import wx
lognull = wx.LogNull()
with warnings.catch_warnings():
    warnings.simplefilter('ignore')
    import schizoidpy
    from schizoidpy import StimGroup
del lognull
from psychopy.visual import ImageStim, Rect, Circle
from psychopy.core import CountdownTimer
from random import random, lognormvariate, expovariate, sample
from cgi import escape
from sys import argv
from collections import Counter

par = dict(zip(argv[1::2], argv[2::2])) # DEPLOYMENT SCRIPT EDITS THIS LINE

o = schizoidpy.Task(
    debug_log_dir = par['debug_log_dir'],
    send_actiview_trigger_codes = par['eeg'],
    inpout32_addr = par['inpout32_addr'],
    double_draw = par['double_draw'],
    shrink_screen = par['shrink_screen'],
    button_radius = .12,
    okay_button_pos = (0, -.7),
    bg_color = 'black', fixation_cross_color = 'white')
o.save('task_version', par['task_version'])

# ------------------------------------------------------------
# * Data
# ------------------------------------------------------------

# Various kinds of fluff (like interests and poll responses) have
# more values defined here than can be shown to any one subject.
# The uses of shuffled() and zip() in the code mean that each
# subject will see random subsets.

male_names = {'Ryan', 'Michael', 'Jake', 'Elijah', 'Corey', 'Travis', 'PLACEHOLDER'}
extra_male_name = 'Ben'
female_names = {'Jen', 'Victoria', 'Emma', 'Emily', 'Gabby', 'Melanie', 'PLACEHOLDER'}
extra_female_name = 'Marika'
portrait_dims = (144, 216)
male_portraits = {'m-adult-{}.jpg'.format(n + 1) for n in range(len(male_names))}
female_portraits = {'f-adult-{}.jpg'.format(n + 1) for n in range(len(female_names))}
locations = {
    'Banff, AB',
    'Brampton, ON',
    'Corner Brook, NL',
    'Halifax, NS',
    'London, ON',
    'Mississauga, ON',
    'Montreal, QC',
    'Montreal, QC',
    'Niagara, NY',
    'Quebec City, QC',
    'Red Deer, AB',
    'Sherbrooke, QC',
    'Toronto, ON',
    'Vancouver, BC'}
interests = {
    'eating, going to the gym, playing music',
    "I draw funny caricatures of people I don't like",
    'I like fashion, and staying informed about national and international politics!',
    'I like going on nature walks',
    'I like taking photographs of food',
    'I like writing my own screen dramas, with me being the star!',
    'I love sports, especially volleyball. I play on the varsity team',
    "I'm really interested in computers. I love taking them apart to see how they work and then putting them back together",
    "Karaoke any time, any where.",
    'playing piano and running',
    'Politics, reading, drama tv shows, running, photography...I have too many!',
    "Teaching myself new (not necessarily useful) skills like juggling.",
    'PLACEHOLDER'}
ages = map(str, [
    1, 1, # PLACEHOLDERS
    18,
    19, 19, 19, 19,
    20, 20, 20,
    21, 21, 21])

round_descriptions = [
    dict(place = 'Kauai',
        background = 'Hanalei,_Kauai_HI.jpg',
        fluff = "Welcome to Kauai, the geologically oldest of the Hawaiian Islands! You are getting closer to the Big Island of Hawaii. Let's play another round.",
        question = 'Who do you most admire?',
        responses = ['Carey Price', 'definitely my mom', 'in general, people who have goals and try their best to achieve them', 'Jon Stewart.', 'Malala Yousafzai', 'my aunt!', 'my best friend', 'My dad', 'my Grandpa', 'my high school English teacher', 'My older sister', 'Oprah Winfrey', 'PLACEHOLDER']),
    dict(place = 'Oahu',
        background = 'Sunset_next_to_Waikiki_Beach,_Oahu,_Hawai,_USA1.jpg',
        fluff = "Welcome to Oahu, the third-largest of the Hawaiian Islands! You are getting closer and closer to the Big Island. Let's play another round.",
        question = "What's your least favorite thing to do (that you have to do anyway)?",
        responses = ['babysitting anyone under 18', 'cleaning the bathroom', 'Doing dirty dishes', 'Flossing', 'going to the gym', 'I am very afraid of taking the plane', 'I hate being involved in boring conversations', 'Laundry', 'Put together IKEA furniture.', 'Study', 'Studying', 'unclog/clean drains of any kind.']),
    dict(place = 'Molokai',
        background = 'Church_at_the_end_of_the_road.jpg',
        fluff = "Welcome to Molokai, an island built from two shield volcanoes and one step closer to the Big Island. Let's play again.",
        question = 'If you could bring only one thing to a desert island, what would it be?',
        responses = ['a fishing rod', 'Adele\'s latest album, although "Hello" might get a bit depressing.', 'An adequate food supply', 'an intelligent answer would be to bring a paddle or something to get out of there, but I guess I would bring a huge bag of chips', 'I would bring my dog to keep me company', "lotssssss of books, like when you think it's enough but then add more", 'my iPhone', 'my running shoes', 'my ukulele', 'peanut butter', "probably a coffee maker, I can't live without coffee!", 'the biggest bag of Cheetos possible.']),
    dict(place = 'Lanai',
        background = 'Full_moon_setting_over_Lanai.jpg',
        fluff = "Welcome to Lanai, a comma-shaped island that was once covered with pineapple plantations. You're the nearest you've come to the Big Island yet, but which of you will make it there? Let's play another round.",
        question = "What's your favorite subject in school?",
        responses = ['Analysis of Markets (an economics class)', 'any science, especially biology', 'Art!!', 'biology', 'computer science', 'Drama', 'drama!', 'Economics.', 'English', 'history', 'International politics!', 'physics and math']),
    dict(place = 'Maui',
        background = 'Kipahulu_coast.jpg',
        fluff = "Welcome to Maui, the second-largest of the Hawaiian Islands! You're almost there! Let's play again to see who will make it to the Big Island of Hawaii.",
        question = "What's your favorite word?",
        responses = ['Clown', "I think I'll say eloquence, I love the meaning and the way it sounds", 'Kafuffle', 'Microsoft', 'Moist', 'Pizzazz', 'Pumpernickel', 'Sizzle', 'ukulele', 'wanderlust', 'Wasabi', 'yolo! Haha'])]

round_wait = 2

# The format of EEG trigger codes is as follows:
#
# Bits 0–2: Encodes the type of event.
events = dict(
    # We skip 0 because that's a control code.
    subject_votes_to_accept   = 0b00000001,
    subject_votes_to_reject   = 0b00000010,
    subject_votes_neutral     = 0b00000011,
    subject_gets_accept_vote  = 0b00000100,
    subject_gets_reject_vote  = 0b00000101,
    subject_gets_neutral_vote = 0b00000110)
# Bit 3: Encodes coplayer gender (0 male, 1 female).
# Bits 4–6: Encodes the coplayer involved in the event. These
#   ID numbers are gender-specific (e.g., male coplayer 3 and
#   female coplayer 3 are different coplayers).
# Bit 7: Always 0, avoiding confusion with codes 255 and 256
#   (which are more control codes).
def trigger_code(coplayer, event):
    return (
        (coplayer['trigger_id'] << 4) |
        (coplayer['female'] << 3) |
        events[event])

# ------------------------------------------------------------
# * Helper functions
# ------------------------------------------------------------

def shuffled(x): return sample(x, len(x))
def choice(x): return shuffled(x)[0]
  # random.choice doesn't work on sets.

def image_path(image):
    return par['image_dir'] + image

big_canvas = Rect(o.win,
    width = 1.5, height = 1.8,
    fillColor = 'white', opacity = .8)
strip_canvas = Rect(o.win,
    width = 1.2, height = .3,
    fillColor = 'white', opacity = .8)
background_imagestim = ImageStim(o.win,
    image_path('Niihau_sep_2007.jpg'),
    units = 'pix',
    size = [o.screen_width, o.screen_height])

def background(image_name):
    background_imagestim.setImage(image_path(image_name))
    return o.showing(background_imagestim, big_canvas)

def message(duration, string):
    # Temporarily replace big_canvas with strip_canvas.
    with o.hiding(big_canvas):
        o.wait_screen(duration,
            strip_canvas,
            o.text(0, 0, string, wrap = 1.2))

blank_background = o.hiding(background_imagestim, big_canvas)

def lag(duration):
    message(duration, u'Waiting for all players to finish…')

# ------------------------------------------------------------
# * Coplayers
# ------------------------------------------------------------

class VoteType(object):
    def __init__(self, letter):
        self.letter = letter
    def __str__(self):
        return self.letter
Reject = VoteType('R')
Neutral = VoteType('N')
Accept = VoteType('A')

coplayers = dict(

    mean3 = dict(expendable = False,
        votes = (Reject, Reject, Reject, Neutral, Reject, Reject)),
    mean2 = dict(expendable = False,
        votes = (Reject, Reject, Neutral, Reject, Reject, Neutral)),
    mean1 = dict(expendable = False,
        votes = (Neutral, Reject, Reject, Accept, Reject, Neutral)),
    indiff = dict(expendable = False,
        votes = (Neutral, Neutral, Neutral, Reject, Accept, Neutral)),
    nice1 = dict(expendable = False,
        votes = (Accept, Neutral, Accept, Accept, Neutral, Reject)),
    nice2 = dict(expendable = False,
        votes = (Accept, Accept, Accept, Neutral, Neutral, Accept)),
    nice3 = dict(expendable = False,
        votes = (Accept, Accept, Neutral, Accept, Accept, Accept)),

    xpendable_rna = dict(expendable = True,
        votes = (Reject, Neutral, Accept, Reject, Neutral, Accept)),
    xpendable_ran = dict(expendable = True,
        votes = (Reject, Accept, Neutral, Reject, Accept, Neutral)),
    xpendable_nra = dict(expendable = True,
        votes = (Neutral, Reject, Accept, Neutral, Reject, Accept)),
    xpendable_nar = dict(expendable = True,
        votes = (Neutral, Accept, Reject, Neutral, Accept, Reject)),
    xpendable_arn = dict(expendable = True,
        votes = (Accept, Reject, Neutral, Accept, Reject, Neutral)),
    xpendable_anr = dict(expendable = True,
        votes = (Accept, Neutral, Reject, Accept, Neutral, Reject)))
for k, p in sorted(coplayers.items()):
    p['id'] = k
    p['poll_responses'] = len(p['votes']) * [None]
coplayers = coplayers.values()

# Enable this block to show the properties of the matrix of votes
# among the non-expendable coplayers.
if False:
    mat = [cp['votes']
        for x in ('mean3', 'mean2', 'mean1', 'indiff', 'nice1', 'nice2', 'nice3')
        for cp in coplayers
        if cp['id'] == x]
    print 'Totals'
    for votetype in Reject, Neutral, Accept:
        print votetype, sum(1 for row in mat for v in row if v is votetype)
    print ''
    print 'Columns'
    ncol = len(mat[0])
    for votetype in Reject, Neutral, Accept:
        print votetype, ' '.join(
            str(sum(1 for row in mat if row[i] == votetype))
            for i in range(ncol))
    print ''
    print 'Rows'
    from collections import Counter
    for row in mat:
        d = Counter(row)
        print 'R {}, N {}, A {}'.format(d[Reject], d[Neutral], d[Accept])
    exit()

# Decide what order the expendables will be kicked out. We choose
# a random order that will result in the subject getting an equal
# number of each type of vote.
while True:
    kickout_order = shuffled([p for p in coplayers if p['expendable']])
    counts = Counter([vote
        for i, cp in enumerate(kickout_order)
        for vote in cp['votes'][: i + 1]])
    if len(counts.keys()) == len('RNA') and len(set(counts.values())) == 1:
        break
o.save('coplayer_kickout_order', [p['id'] for p in kickout_order])

# Make the coplayers evenly split by gender within the expendable
# and non-expendable groups.
for e in [True, False]:
    for i, p in enumerate(shuffled(
            [p for p in coplayers if p['expendable'] == e])):
        p['female'] = bool(i % 2)
  # Because there's an odd number of non-expendable coplayers,
  # we're left with one more male than we have females. Later,
  # if we learn that the subject is male, we'll make one of
  # the male non-expendables female.

def pronoun_nom(p): return 'she' if p['female'] else 'he'
def pronoun_obj(p): return 'her' if p['female'] else 'him'
def pronoun_gen(p): return 'her' if p['female'] else 'his'

# Assign names and portraits.
males = zip(shuffled(male_names), shuffled(male_portraits))
females = zip(shuffled(female_names), shuffled(female_portraits))
for p in coplayers:
    p['name'], p['portrait'] = females.pop() if p['female'] else males.pop()

portrait_stim_cache = {}
def portrait_stim(x, y, p, border_color = 'black'):
    img = par['subject_portrait_path'] if p is None else image_path(p['portrait'])
    k = x, y, border_color, img
    if k not in portrait_stim_cache:
        portrait_stim_cache[k] = StimGroup((
            ImageStim(o.win, pos = (x, y),
                image = img),
            Rect(o.win, pos = (x, y),
                width = (portrait_dims[0] + 3) / (.5 * o.screen_width),
                height = (portrait_dims[1] + 3) / (.5 * o.screen_height),
                lineColor = border_color, lineWidth = 3)))
    return portrait_stim_cache[k]

# Assign fluff.
for p, age, hometown, interest in zip(
        coplayers, shuffled(ages), shuffled(locations), shuffled(interests)):
    p['fluff'] = dict(
        Age = age, Hometown = hometown, Interests = interest)

o.save('coplayers', {p['id']: p for p in coplayers})
  # We don't copy the coplayer-objects because we want later edits
  # (such as the addition of poll responses) to be recorded.

# ------------------------------------------------------------
# * The voting subroutine
# ------------------------------------------------------------

icon_dim = 200 # Pixels
icon_thickness = 10 # Pixels

def icon_frame(x, color):
    kw = dict(units = 'pix', fillColor = color, lineColor = color)
    return [
        Rect(o.win, icon_dim, icon_thickness,
            pos = (x, icon_dim/2 - icon_thickness/2), **kw),
        Rect(o.win, icon_dim, icon_thickness,
            pos = (x, -icon_dim/2 + icon_thickness/2), **kw),
        Rect(o.win, icon_thickness, icon_dim,
            pos = (x + icon_dim/2, 0), **kw),
        Rect(o.win, icon_thickness, icon_dim,
            pos = (x - icon_dim/2, 0), **kw)]

def reject_icon(x = 0):
    return ImageStim(o.win, pos = (x, 0),
        image = image_path('thumbs-down.png'))
Reject.icon_c = reject_icon()

def accept_icon(x = 0):
    return ImageStim(o.win, pos = (x, 0),
        image = image_path('thumbs-up.png'))
Accept.icon_c = accept_icon()

def neutral_icon(x = 0):
    return ImageStim(o.win, pos = (x, 0),
        image = image_path('thumbs-side.png'))
Neutral.icon_c = neutral_icon()

def voting(nround):

    practice = nround is None
    if practice:
        cps = [
            dict(id = 'practice_a',
                 name = 'Player A', female = False,
                 portrait = 'example-male.png',
                 vote = Accept),
            dict(id = 'practice_b',
                 name = 'Player B', female = True,
                 portrait = 'example-female.png',
                 vote = Reject)]
    else:
        cps = shuffled(coplayers)
        o.save('vote_order', [p['id'] for p in cps])
    with blank_background:
      for i, p in enumerate(cps):

        if not practice:
          # Choose an amount of time that we're pretending the
          # coplayer takes to vote. The random distribution here is
          # made to be similar to the real distribution of voting
          # times from past subjects, biased against very long waits
          # (since we don't want to waste subjects' time).
            varwait = lognormvariate(.5, .75)
            o.save(('feedback_varwait', i), varwait)
            feedback_timer = CountdownTimer(varwait)

        # The subject votes.
        s_vote = o.button_screen(('subject_votes', p['id']),
            portrait_stim(-.5, .5, p, border_color = 'white'),
            o.html(.2, .8, vAlign = 'top', color = 'white', font_size = 14, string =
                # Show everything the subject knows about this
                # coplayer, except for observed voting behavior.
                p['name'] + "<br><br>" +
                '<b>{}</b><br>'.format('Female' if p['female'] else 'Male') +
                ('' if practice else '<br>'.join(
                    ['<b>{}:</b> {}'.format(k, escape(p['fluff'][k])) for k in
                        ['Age', 'Hometown', 'Interests']] +
                    ['<b>{}:</b> {}'.format(
                            escape(r['question']),
                            escape(p['poll_responses'][i + 1]))
                        for i, r in enumerate(round_descriptions)
                        if i + 1 <= nround]))),
            o.text(0, -.5, color = 'white', wrap = 2, string =
                'Should we keep {} or kick {} out?'.format(
                    p['name'], pronoun_obj(p))),
            o.button(-.3, -.7, 'Kick\nOut', None if practice else
                trigger_code(p, 'subject_votes_to_reject')),
            o.button(0, -.7, 'Neutral', None if practice else
                trigger_code(p, 'subject_votes_neutral')),
            o.button(.3, -.7, 'Keep', None if practice else
                trigger_code(p, 'subject_votes_to_accept')))

        if not practice:
          # If the subject voted more quickly than we're pretending
          # the coplayer did, make the subject wait.
            o.wait_screen_till(feedback_timer, o.text(0, 0, color = 'white', string =
                u'Waiting for {} to vote…'.format(p['name'])))

        # Show a fixation cross.
        o.wait_screen(1, o.fixation_cross)

        # Now show the coplayer's vote.
        pv = p['vote'] if practice else p['votes'][nround]
        if not practice: o.trigger(trigger_code(p, {
            Reject: 'subject_gets_reject_vote',
            Neutral: 'subject_gets_neutral_vote',
            Accept: 'subject_gets_accept_vote'}[pv]))
        o.wait_screen(2, pv.icon_c)
        o.wait_screen(1.5)

    if not practice:
      # An expendable coplayer is ousted.
        loser = kickout_order[nround]
        coplayers.remove(loser)
        o.okay_screen('loser',
            portrait_stim(0, .5, loser),
            o.text(0, -.2, "And it's final decision time. Looks like {} got the least points! {} journey ends here. You get to continue on to the next island!".format(
                loser['name'],
                pronoun_gen(loser).capitalize())))

# ------------------------------------------------------------
# * Preliminaries
# ------------------------------------------------------------

if par['debug']:
    o.data['subject'] = 'test'
else:
    o.get_subject_id('Island Getaway')

subject_name = '???'

o.start_clock()

# ------------------------------------------------------------
# * Introduction
# ------------------------------------------------------------

with background('Hawaje-NoRedLine.jpg'):

    message(2, 'Aloha!')

    with o.dkey_prefix('introduction'):

        o.instructions('set_the_scene', "Let's pretend you've just landed on the Hawaiian Island of Niihau to begin a summer vacation with a group of {} other students. But the journey isn't over yet! First, you must make your way along the islands to get to the Big Island of Hawaii. Once there, your vacation will begin!".format(
            len(coplayers)))

        o.instructions('game_overview', "As you travel along the islands, you'll get to know more and more about the other players. After each round, you'll vote for who you would like to continue on to the Big Island with you and who you would like to send home. But the other players will also be voting on you! And your goal is to stay in the game and be one of the {} players (out of the original {}) who make it to the Big Island!".format(
            len(coplayers) + 1 - (len(round_descriptions) + 1),
            len(coplayers) + 1))

    with o.dkey_prefix('profile'):

        o.button_screen('gender',
           o.text(0, .8, 'Now you can fill out your profile.\n\nAre you male or female?', vAlign = 'top'),
           o.button(-.25, -.7, 'Male'),
           o.button(.25, -.7, 'Female'))
        if o.data['profile']['gender'] == 'Male':
            # Make a male non-expendable female so that there's
            # of equal number of male and female players.
            transgal = choice([p for p in coplayers if not p['female']])
            transgal['female'] = True
            transgal['name'], = female_names - {p['name'] for p in coplayers if p['female']}
            transgal['portrait'], = female_portraits - {p['portrait'] for p in coplayers if p['female']}

        o.text_entry_screen('name', 'What is your first name?')
        subject_name = o.data['profile']['name']
        # Try to normalize capitalization.
        if subject_name.isalpha() and (
                subject_name.islower() or
                    (len(subject_name) > 2 and subject_name.isupper())):
                      # Don't downcase "AJ".
            subject_name = subject_name.lower().capitalize()
        # If the subject's name exactly matches the name of a
        # coplayer (case-insensitively), rename the coplayer.
        try:
            p = next(p for p in coplayers if
                p['name'].lower() == subject_name.lower())
            p['name'] = extra_female_name if p['female'] else extra_male_name
        except StopIteration:
            pass

        o.nonneg_int_entry_screen('age', 'How old are you?')

        o.text_entry_screen('hometown', 'What is your hometown?')

        o.text_entry_screen('interests', "What are some things you're interested in?")

        o.okay_screen('view',
            portrait_stim(0, .5, None),
            o.html(0, 0,
                subject_name + "<br><br>" +
                '<b>{}</b><br>'.format(o.data['profile']['gender']) +
                '<br>'.join(
                    '<b>{}:</b> {}'.format(k.capitalize(), escape(o.data['profile'][k])) for k in
                        ['age', 'hometown', 'interests'])))

    lag(3)

# Now that the coplayers' genders are set, we can assign trigger
# codes.
seen_genders = [0, 0]
for p in coplayers:
    p['trigger_id'] = seen_genders[p['female']]
    seen_genders[p['female']] += 1

# ------------------------------------------------------------
# * Round 0
# ------------------------------------------------------------

with o.dkey_prefix(('round', 0)), background('Niihau_sep_2007.jpg'):

    message(round_wait, 'Round 1: Niihau')

    o.instructions('read_profiles', 'Take a moment to learn about the other players.')

    cps = shuffled(coplayers)
    o.save('profile_order', [p['id'] for p in cps])
    for i, p in enumerate(cps):
        o.okay_screen(('fluff', i),
            portrait_stim(0, .5, p),
            o.html(0, 0,
                p['name'] + "<br><br>" +
                '<b>{}</b><br>'.format('Female' if p['female'] else 'Male') +
                '<br>'.join(
                    '<b>{}:</b> {}'.format(k, escape(p['fluff'][k])) for k in
                        ['Age', 'Hometown', 'Interests'])))

    o.instructions('voting_begins', html = True, string = "And on to the first round of voting. Who do you want to send home? And who do you want to continue with on to the next island? You can vote to keep or send home as many players as you want, but you have to vote to send <b>at least one</b> other player home. Whoever gets the most votes to be sent home will be kicked off the island, with ties broken randomly.<br><br>Each time you vote, you will then find out how that player voted for you.")

    o.okay_screen('feedback_explanation',
        o.text(0, .7, "For each player, after you've made your own vote, you'll see an icon that shows their vote."),
        accept_icon(-.4),
        o.text(-.4, -.3, "This means a vote to keep you.",
            vAlign = 'top', wrap = .6),
        reject_icon(.4),
        o.text(.4, -.3, "This means a vote to kick you out.",
            vAlign = 'top', wrap = .6))

    with o.dkey_prefix('voting_practice'):
        o.instructions('intro', "First, you'll see two examples of how voting works.")
        voting(None)
        o.instructions('done', 'Now for the first round of real voting.')

    voting(0)

# ------------------------------------------------------------
# * All other rounds
# ------------------------------------------------------------

for i, r in enumerate(round_descriptions):
    nround = i + 1
    with o.dkey_prefix(('round', nround)), background(r['background']):

        message(round_wait, 'Round {}: {}'.format(nround + 1, r['place']))
        o.instructions('fluff', r['fluff'])

        o.text_entry_screen('poll_question',
            "Now you'll all answer another question so you can get to know each other better.\n\n" +
            r['question'])

        for p, resp in zip(coplayers, shuffled(r['responses'])):
            p['poll_responses'][nround] = resp
        varwait = max(expovariate(2) for _ in coplayers)
        o.save('poll_varwait', varwait)
        lag(varwait)

        responses = shuffled(
            [(p['id'], p['name'], p['poll_responses'][nround]) for p in coplayers] +
            [('SUBJECT', subject_name, o.data['round'][nround]['poll_question'])])
        o.save('poll_response_order', [r[0] for r in responses])
        o.okay_screen('poll_results',
            o.text(0, .8, "Here are your responses:"),
            o.html(0, .65,
                "<br>".join(["<b>{}</b>: {}".format(escape(r[1]), escape(r[2])) for r in responses]),
                wrap = 1.4, vAlign = 'top'))

        voting(nround)

# ------------------------------------------------------------
# * A winner is you!
# ------------------------------------------------------------

with background('Rainbow_over_palms_at_Big_Island_of_Hawaii.jpg'):
    message(3, 'You made it to the Big Island of Hawaii!\nLet the vacation begin!')

# ------------------------------------------------------------
# * Post-game questionnaire
# ------------------------------------------------------------

o.questionnaire_screen('postgame_questionnaire', 'In the below questionnaire, pick the options that best represent the feelings you were experiencing during the game.',
    prompt_color = 'white',
    scale_levels = ('Not at all', 'Slightly', 'Somewhat', 'Quite a lot', 'Extremely'),
    questions = [
        {'id': ('belonging', 1), 'text': "I felt I didn't fit in with the others."},
        {'id': ('other', 1), 'text': 'It bothered me to vote off other players.'},
        {'id': ('self-esteem', 2), 'text': 'My self-esteem was high.'},
        {'id': ('task disengagement', 5), 'text': 'I really wanted to stay in the game.'},
        {'id': ('self-esteem', 3), 'text': 'I felt liked.'},
        {'id': ('self-esteem', 4), 'text': 'I felt unsure of myself.'},
        {'id': ('belonging', 5), 'text': 'I felt the other players wanted me to continue on to the Big Island.'},
        {'id': ('preoccupation with exclusion', 1), 'text': 'I wondered "Why did they vote me off?"'},
        {'id': ('task disengagement', 2), 'text': 'After a while I lost interest in staying in the game.'},
        {'id': ('survivor', 1), 'text': 'It bothered me to vote off other players.'},
        {'id': ('belonging', 2), 'text': 'I felt rejected.'},
        {'id': ('belonging', 4), 'text': 'I felt I belonged to the group.'},
        {'id': ('survivor', 2), 'text': 'I wondered why other players voted me off.'},
        {'id': ('control', 4), 'text': 'I felt I was unable to influence the action of others.'},
        {'id': ('task disengagement', 3), 'text': "I would've liked to play this game again."},
        {'id': ('control', 2), 'text': 'I felt I had control over the course of the game.'},
        {'id': ('self-esteem', 1), 'text': 'I felt good about myself.'},
        {'id': ('meaningful existence', 2), 'text': "I felt I didn't matter."}])

# ------------------------------------------------------------
# * Done!
# ------------------------------------------------------------

def jf(x):
    if x is Reject:
        return -1
    elif x is Neutral:
        return 0
    elif x is Accept:
        return 1
    else:
        raise TypeError

o.done(par['output_path_fmt'].format(**o.data),
    json_default = jf)
print '### Data written to', par['output_path_fmt'].format(**o.data)

o.wait_screen(1,
    o.text(0, 0, color = 'white', string = 'Done!\n\nPlease let the experimenter know you are done.'))
